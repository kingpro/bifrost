// Code generated by protoc-gen-go. DO NOT EDIT.
// source: callback.proto

package callback

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ErrCode int32

const (
	ErrCode_ErrOK ErrCode = 0
	// 以下 字段已经被遗弃
	ErrCode_ErrSkip       ErrCode = 1
	ErrCode_ErrAbort      ErrCode = 2
	ErrCode_ErrContinue   ErrCode = 3
	ErrCode_ErrDisconnect ErrCode = 4
	ErrCode_ErrAuthFailed ErrCode = 5
)

var ErrCode_name = map[int32]string{
	0: "ErrOK",
	1: "ErrSkip",
	2: "ErrAbort",
	3: "ErrContinue",
	4: "ErrDisconnect",
	5: "ErrAuthFailed",
}

var ErrCode_value = map[string]int32{
	"ErrOK":         0,
	"ErrSkip":       1,
	"ErrAbort":      2,
	"ErrContinue":   3,
	"ErrDisconnect": 4,
	"ErrAuthFailed": 5,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{0}
}

type OnConnectRequest struct {
	Username             string   `protobuf:"bytes,1,opt,name=Username,proto3" json:"Username,omitempty"`
	Password             []byte   `protobuf:"bytes,2,opt,name=Password,proto3" json:"Password,omitempty"`
	ClientID             string   `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	CleanSession         bool     `protobuf:"varint,4,opt,name=CleanSession,proto3" json:"CleanSession,omitempty"`
	Address              string   `protobuf:"bytes,5,opt,name=Address,proto3" json:"Address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnConnectRequest) Reset()         { *m = OnConnectRequest{} }
func (m *OnConnectRequest) String() string { return proto.CompactTextString(m) }
func (*OnConnectRequest) ProtoMessage()    {}
func (*OnConnectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{0}
}

func (m *OnConnectRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnConnectRequest.Unmarshal(m, b)
}
func (m *OnConnectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnConnectRequest.Marshal(b, m, deterministic)
}
func (m *OnConnectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnConnectRequest.Merge(m, src)
}
func (m *OnConnectRequest) XXX_Size() int {
	return xxx_messageInfo_OnConnectRequest.Size(m)
}
func (m *OnConnectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnConnectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnConnectRequest proto.InternalMessageInfo

func (m *OnConnectRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *OnConnectRequest) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *OnConnectRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnConnectRequest) GetCleanSession() bool {
	if m != nil {
		return m.CleanSession
	}
	return false
}

func (m *OnConnectRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type OnConnectReply struct {
	ConnectCode          ErrCode  `protobuf:"varint,1,opt,name=ConnectCode,proto3,enum=callback.ErrCode" json:"ConnectCode,omitempty"`
	Cookie               []byte   `protobuf:"bytes,2,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	StatLabel            string   `protobuf:"bytes,3,opt,name=StatLabel,proto3" json:"StatLabel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnConnectReply) Reset()         { *m = OnConnectReply{} }
func (m *OnConnectReply) String() string { return proto.CompactTextString(m) }
func (*OnConnectReply) ProtoMessage()    {}
func (*OnConnectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{1}
}

func (m *OnConnectReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnConnectReply.Unmarshal(m, b)
}
func (m *OnConnectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnConnectReply.Marshal(b, m, deterministic)
}
func (m *OnConnectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnConnectReply.Merge(m, src)
}
func (m *OnConnectReply) XXX_Size() int {
	return xxx_messageInfo_OnConnectReply.Size(m)
}
func (m *OnConnectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnConnectReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnConnectReply proto.InternalMessageInfo

func (m *OnConnectReply) GetConnectCode() ErrCode {
	if m != nil {
		return m.ConnectCode
	}
	return ErrCode_ErrOK
}

func (m *OnConnectReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *OnConnectReply) GetStatLabel() string {
	if m != nil {
		return m.StatLabel
	}
	return ""
}

//TODO repeated topics
type SubscribeTopics struct {
	Topic                string   `protobuf:"bytes,1,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Qos                  int32    `protobuf:"varint,2,opt,name=Qos,proto3" json:"Qos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeTopics) Reset()         { *m = SubscribeTopics{} }
func (m *SubscribeTopics) String() string { return proto.CompactTextString(m) }
func (*SubscribeTopics) ProtoMessage()    {}
func (*SubscribeTopics) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{2}
}

func (m *SubscribeTopics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeTopics.Unmarshal(m, b)
}
func (m *SubscribeTopics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeTopics.Marshal(b, m, deterministic)
}
func (m *SubscribeTopics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeTopics.Merge(m, src)
}
func (m *SubscribeTopics) XXX_Size() int {
	return xxx_messageInfo_SubscribeTopics.Size(m)
}
func (m *SubscribeTopics) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeTopics.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeTopics proto.InternalMessageInfo

func (m *SubscribeTopics) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *SubscribeTopics) GetQos() int32 {
	if m != nil {
		return m.Qos
	}
	return 0
}

type OnSubscribeRequest struct {
	SubTopics            []*SubscribeTopics `protobuf:"bytes,1,rep,name=SubTopics,proto3" json:"SubTopics,omitempty"`
	ClientID             string             `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Cookie               []byte             `protobuf:"bytes,3,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *OnSubscribeRequest) Reset()         { *m = OnSubscribeRequest{} }
func (m *OnSubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*OnSubscribeRequest) ProtoMessage()    {}
func (*OnSubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{3}
}

func (m *OnSubscribeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnSubscribeRequest.Unmarshal(m, b)
}
func (m *OnSubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnSubscribeRequest.Marshal(b, m, deterministic)
}
func (m *OnSubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnSubscribeRequest.Merge(m, src)
}
func (m *OnSubscribeRequest) XXX_Size() int {
	return xxx_messageInfo_OnSubscribeRequest.Size(m)
}
func (m *OnSubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnSubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnSubscribeRequest proto.InternalMessageInfo

func (m *OnSubscribeRequest) GetSubTopics() []*SubscribeTopics {
	if m != nil {
		return m.SubTopics
	}
	return nil
}

func (m *OnSubscribeRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnSubscribeRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type OnSubscribeReply struct {
	Successes            []bool   `protobuf:"varint,2,rep,packed,name=Successes,proto3" json:"Successes,omitempty"`
	Cookie               []byte   `protobuf:"bytes,3,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnSubscribeReply) Reset()         { *m = OnSubscribeReply{} }
func (m *OnSubscribeReply) String() string { return proto.CompactTextString(m) }
func (*OnSubscribeReply) ProtoMessage()    {}
func (*OnSubscribeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{4}
}

func (m *OnSubscribeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnSubscribeReply.Unmarshal(m, b)
}
func (m *OnSubscribeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnSubscribeReply.Marshal(b, m, deterministic)
}
func (m *OnSubscribeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnSubscribeReply.Merge(m, src)
}
func (m *OnSubscribeReply) XXX_Size() int {
	return xxx_messageInfo_OnSubscribeReply.Size(m)
}
func (m *OnSubscribeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnSubscribeReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnSubscribeReply proto.InternalMessageInfo

func (m *OnSubscribeReply) GetSuccesses() []bool {
	if m != nil {
		return m.Successes
	}
	return nil
}

func (m *OnSubscribeReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type PostSubscribeRequest struct {
	SubTopics            []*SubscribeTopics `protobuf:"bytes,1,rep,name=SubTopics,proto3" json:"SubTopics,omitempty"`
	ClientID             string             `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Cookie               []byte             `protobuf:"bytes,3,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PostSubscribeRequest) Reset()         { *m = PostSubscribeRequest{} }
func (m *PostSubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*PostSubscribeRequest) ProtoMessage()    {}
func (*PostSubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{5}
}

func (m *PostSubscribeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PostSubscribeRequest.Unmarshal(m, b)
}
func (m *PostSubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PostSubscribeRequest.Marshal(b, m, deterministic)
}
func (m *PostSubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostSubscribeRequest.Merge(m, src)
}
func (m *PostSubscribeRequest) XXX_Size() int {
	return xxx_messageInfo_PostSubscribeRequest.Size(m)
}
func (m *PostSubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PostSubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PostSubscribeRequest proto.InternalMessageInfo

func (m *PostSubscribeRequest) GetSubTopics() []*SubscribeTopics {
	if m != nil {
		return m.SubTopics
	}
	return nil
}

func (m *PostSubscribeRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *PostSubscribeRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type PostSubscribeReply struct {
	Cookie               []byte   `protobuf:"bytes,2,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PostSubscribeReply) Reset()         { *m = PostSubscribeReply{} }
func (m *PostSubscribeReply) String() string { return proto.CompactTextString(m) }
func (*PostSubscribeReply) ProtoMessage()    {}
func (*PostSubscribeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{6}
}

func (m *PostSubscribeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PostSubscribeReply.Unmarshal(m, b)
}
func (m *PostSubscribeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PostSubscribeReply.Marshal(b, m, deterministic)
}
func (m *PostSubscribeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PostSubscribeReply.Merge(m, src)
}
func (m *PostSubscribeReply) XXX_Size() int {
	return xxx_messageInfo_PostSubscribeReply.Size(m)
}
func (m *PostSubscribeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_PostSubscribeReply.DiscardUnknown(m)
}

var xxx_messageInfo_PostSubscribeReply proto.InternalMessageInfo

func (m *PostSubscribeReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type OnPublishRequest struct {
	Topic                string   `protobuf:"bytes,1,opt,name=Topic,proto3" json:"Topic,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Qos                  int32    `protobuf:"varint,3,opt,name=Qos,proto3" json:"Qos,omitempty"`
	Message              []byte   `protobuf:"bytes,4,opt,name=Message,proto3" json:"Message,omitempty"`
	Cookie               []byte   `protobuf:"bytes,5,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	StatLabel            string   `protobuf:"bytes,6,opt,name=StatLabel,proto3" json:"StatLabel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnPublishRequest) Reset()         { *m = OnPublishRequest{} }
func (m *OnPublishRequest) String() string { return proto.CompactTextString(m) }
func (*OnPublishRequest) ProtoMessage()    {}
func (*OnPublishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{7}
}

func (m *OnPublishRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnPublishRequest.Unmarshal(m, b)
}
func (m *OnPublishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnPublishRequest.Marshal(b, m, deterministic)
}
func (m *OnPublishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnPublishRequest.Merge(m, src)
}
func (m *OnPublishRequest) XXX_Size() int {
	return xxx_messageInfo_OnPublishRequest.Size(m)
}
func (m *OnPublishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnPublishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnPublishRequest proto.InternalMessageInfo

func (m *OnPublishRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *OnPublishRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnPublishRequest) GetQos() int32 {
	if m != nil {
		return m.Qos
	}
	return 0
}

func (m *OnPublishRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *OnPublishRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *OnPublishRequest) GetStatLabel() string {
	if m != nil {
		return m.StatLabel
	}
	return ""
}

type OnPublishReply struct {
	Skip                 bool     `protobuf:"varint,1,opt,name=Skip,proto3" json:"Skip,omitempty"`
	Cookie               []byte   `protobuf:"bytes,2,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	BizID                []byte   `protobuf:"bytes,3,opt,name=BizID,proto3" json:"BizID,omitempty"`
	Message              []byte   `protobuf:"bytes,4,opt,name=Message,proto3" json:"Message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnPublishReply) Reset()         { *m = OnPublishReply{} }
func (m *OnPublishReply) String() string { return proto.CompactTextString(m) }
func (*OnPublishReply) ProtoMessage()    {}
func (*OnPublishReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{8}
}

func (m *OnPublishReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnPublishReply.Unmarshal(m, b)
}
func (m *OnPublishReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnPublishReply.Marshal(b, m, deterministic)
}
func (m *OnPublishReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnPublishReply.Merge(m, src)
}
func (m *OnPublishReply) XXX_Size() int {
	return xxx_messageInfo_OnPublishReply.Size(m)
}
func (m *OnPublishReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnPublishReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnPublishReply proto.InternalMessageInfo

func (m *OnPublishReply) GetSkip() bool {
	if m != nil {
		return m.Skip
	}
	return false
}

func (m *OnPublishReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *OnPublishReply) GetBizID() []byte {
	if m != nil {
		return m.BizID
	}
	return nil
}

func (m *OnPublishReply) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

type OnUnsubscribeRequest struct {
	Topics               []string `protobuf:"bytes,1,rep,name=Topics,proto3" json:"Topics,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Cookie               []byte   `protobuf:"bytes,3,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	LostConnection       bool     `protobuf:"varint,4,opt,name=LostConnection,proto3" json:"LostConnection,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnUnsubscribeRequest) Reset()         { *m = OnUnsubscribeRequest{} }
func (m *OnUnsubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*OnUnsubscribeRequest) ProtoMessage()    {}
func (*OnUnsubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{9}
}

func (m *OnUnsubscribeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnUnsubscribeRequest.Unmarshal(m, b)
}
func (m *OnUnsubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnUnsubscribeRequest.Marshal(b, m, deterministic)
}
func (m *OnUnsubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUnsubscribeRequest.Merge(m, src)
}
func (m *OnUnsubscribeRequest) XXX_Size() int {
	return xxx_messageInfo_OnUnsubscribeRequest.Size(m)
}
func (m *OnUnsubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUnsubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnUnsubscribeRequest proto.InternalMessageInfo

func (m *OnUnsubscribeRequest) GetTopics() []string {
	if m != nil {
		return m.Topics
	}
	return nil
}

func (m *OnUnsubscribeRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnUnsubscribeRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *OnUnsubscribeRequest) GetLostConnection() bool {
	if m != nil {
		return m.LostConnection
	}
	return false
}

type OnUnsubscribeReply struct {
	Cookie               []byte   `protobuf:"bytes,2,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnUnsubscribeReply) Reset()         { *m = OnUnsubscribeReply{} }
func (m *OnUnsubscribeReply) String() string { return proto.CompactTextString(m) }
func (*OnUnsubscribeReply) ProtoMessage()    {}
func (*OnUnsubscribeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{10}
}

func (m *OnUnsubscribeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnUnsubscribeReply.Unmarshal(m, b)
}
func (m *OnUnsubscribeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnUnsubscribeReply.Marshal(b, m, deterministic)
}
func (m *OnUnsubscribeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnUnsubscribeReply.Merge(m, src)
}
func (m *OnUnsubscribeReply) XXX_Size() int {
	return xxx_messageInfo_OnUnsubscribeReply.Size(m)
}
func (m *OnUnsubscribeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnUnsubscribeReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnUnsubscribeReply proto.InternalMessageInfo

func (m *OnUnsubscribeReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type OnDisconnectRequest struct {
	ClientID             string   `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Cookie               []byte   `protobuf:"bytes,2,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	LostConnection       bool     `protobuf:"varint,3,opt,name=LostConnection,proto3" json:"LostConnection,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnDisconnectRequest) Reset()         { *m = OnDisconnectRequest{} }
func (m *OnDisconnectRequest) String() string { return proto.CompactTextString(m) }
func (*OnDisconnectRequest) ProtoMessage()    {}
func (*OnDisconnectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{11}
}

func (m *OnDisconnectRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnDisconnectRequest.Unmarshal(m, b)
}
func (m *OnDisconnectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnDisconnectRequest.Marshal(b, m, deterministic)
}
func (m *OnDisconnectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnDisconnectRequest.Merge(m, src)
}
func (m *OnDisconnectRequest) XXX_Size() int {
	return xxx_messageInfo_OnDisconnectRequest.Size(m)
}
func (m *OnDisconnectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnDisconnectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnDisconnectRequest proto.InternalMessageInfo

func (m *OnDisconnectRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnDisconnectRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *OnDisconnectRequest) GetLostConnection() bool {
	if m != nil {
		return m.LostConnection
	}
	return false
}

type OnDisconnectReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnDisconnectReply) Reset()         { *m = OnDisconnectReply{} }
func (m *OnDisconnectReply) String() string { return proto.CompactTextString(m) }
func (*OnDisconnectReply) ProtoMessage()    {}
func (*OnDisconnectReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{12}
}

func (m *OnDisconnectReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnDisconnectReply.Unmarshal(m, b)
}
func (m *OnDisconnectReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnDisconnectReply.Marshal(b, m, deterministic)
}
func (m *OnDisconnectReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnDisconnectReply.Merge(m, src)
}
func (m *OnDisconnectReply) XXX_Size() int {
	return xxx_messageInfo_OnDisconnectReply.Size(m)
}
func (m *OnDisconnectReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnDisconnectReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnDisconnectReply proto.InternalMessageInfo

type OnACKRequest struct {
	BizID                []byte   `protobuf:"bytes,1,opt,name=BizID,proto3" json:"BizID,omitempty"`
	ClientID             string   `protobuf:"bytes,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Cookie               []byte   `protobuf:"bytes,3,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnACKRequest) Reset()         { *m = OnACKRequest{} }
func (m *OnACKRequest) String() string { return proto.CompactTextString(m) }
func (*OnACKRequest) ProtoMessage()    {}
func (*OnACKRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{13}
}

func (m *OnACKRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnACKRequest.Unmarshal(m, b)
}
func (m *OnACKRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnACKRequest.Marshal(b, m, deterministic)
}
func (m *OnACKRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnACKRequest.Merge(m, src)
}
func (m *OnACKRequest) XXX_Size() int {
	return xxx_messageInfo_OnACKRequest.Size(m)
}
func (m *OnACKRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnACKRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnACKRequest proto.InternalMessageInfo

func (m *OnACKRequest) GetBizID() []byte {
	if m != nil {
		return m.BizID
	}
	return nil
}

func (m *OnACKRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnACKRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type OnACKReply struct {
	Cookie               []byte   `protobuf:"bytes,2,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnACKReply) Reset()         { *m = OnACKReply{} }
func (m *OnACKReply) String() string { return proto.CompactTextString(m) }
func (*OnACKReply) ProtoMessage()    {}
func (*OnACKReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{14}
}

func (m *OnACKReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnACKReply.Unmarshal(m, b)
}
func (m *OnACKReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnACKReply.Marshal(b, m, deterministic)
}
func (m *OnACKReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnACKReply.Merge(m, src)
}
func (m *OnACKReply) XXX_Size() int {
	return xxx_messageInfo_OnACKReply.Size(m)
}
func (m *OnACKReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnACKReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnACKReply proto.InternalMessageInfo

func (m *OnACKReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

type OnOfflineRequest struct {
	ClientID             string   `protobuf:"bytes,1,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Message              []byte   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Topic                string   `protobuf:"bytes,3,opt,name=Topic,proto3" json:"Topic,omitempty"`
	Cookie               []byte   `protobuf:"bytes,4,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	Subers               []string `protobuf:"bytes,5,rep,name=Subers,proto3" json:"Subers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnOfflineRequest) Reset()         { *m = OnOfflineRequest{} }
func (m *OnOfflineRequest) String() string { return proto.CompactTextString(m) }
func (*OnOfflineRequest) ProtoMessage()    {}
func (*OnOfflineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{15}
}

func (m *OnOfflineRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnOfflineRequest.Unmarshal(m, b)
}
func (m *OnOfflineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnOfflineRequest.Marshal(b, m, deterministic)
}
func (m *OnOfflineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnOfflineRequest.Merge(m, src)
}
func (m *OnOfflineRequest) XXX_Size() int {
	return xxx_messageInfo_OnOfflineRequest.Size(m)
}
func (m *OnOfflineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OnOfflineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OnOfflineRequest proto.InternalMessageInfo

func (m *OnOfflineRequest) GetClientID() string {
	if m != nil {
		return m.ClientID
	}
	return ""
}

func (m *OnOfflineRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *OnOfflineRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *OnOfflineRequest) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *OnOfflineRequest) GetSubers() []string {
	if m != nil {
		return m.Subers
	}
	return nil
}

type OnOfflineReply struct {
	Cookie               []byte   `protobuf:"bytes,1,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OnOfflineReply) Reset()         { *m = OnOfflineReply{} }
func (m *OnOfflineReply) String() string { return proto.CompactTextString(m) }
func (*OnOfflineReply) ProtoMessage()    {}
func (*OnOfflineReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6cf7fe261a3a1c45, []int{16}
}

func (m *OnOfflineReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OnOfflineReply.Unmarshal(m, b)
}
func (m *OnOfflineReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OnOfflineReply.Marshal(b, m, deterministic)
}
func (m *OnOfflineReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnOfflineReply.Merge(m, src)
}
func (m *OnOfflineReply) XXX_Size() int {
	return xxx_messageInfo_OnOfflineReply.Size(m)
}
func (m *OnOfflineReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OnOfflineReply.DiscardUnknown(m)
}

var xxx_messageInfo_OnOfflineReply proto.InternalMessageInfo

func (m *OnOfflineReply) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func init() {
	proto.RegisterEnum("callback.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterType((*OnConnectRequest)(nil), "callback.OnConnectRequest")
	proto.RegisterType((*OnConnectReply)(nil), "callback.OnConnectReply")
	proto.RegisterType((*SubscribeTopics)(nil), "callback.SubscribeTopics")
	proto.RegisterType((*OnSubscribeRequest)(nil), "callback.OnSubscribeRequest")
	proto.RegisterType((*OnSubscribeReply)(nil), "callback.OnSubscribeReply")
	proto.RegisterType((*PostSubscribeRequest)(nil), "callback.PostSubscribeRequest")
	proto.RegisterType((*PostSubscribeReply)(nil), "callback.PostSubscribeReply")
	proto.RegisterType((*OnPublishRequest)(nil), "callback.OnPublishRequest")
	proto.RegisterType((*OnPublishReply)(nil), "callback.OnPublishReply")
	proto.RegisterType((*OnUnsubscribeRequest)(nil), "callback.OnUnsubscribeRequest")
	proto.RegisterType((*OnUnsubscribeReply)(nil), "callback.OnUnsubscribeReply")
	proto.RegisterType((*OnDisconnectRequest)(nil), "callback.OnDisconnectRequest")
	proto.RegisterType((*OnDisconnectReply)(nil), "callback.OnDisconnectReply")
	proto.RegisterType((*OnACKRequest)(nil), "callback.OnACKRequest")
	proto.RegisterType((*OnACKReply)(nil), "callback.OnACKReply")
	proto.RegisterType((*OnOfflineRequest)(nil), "callback.OnOfflineRequest")
	proto.RegisterType((*OnOfflineReply)(nil), "callback.OnOfflineReply")
}

func init() { proto.RegisterFile("callback.proto", fileDescriptor_6cf7fe261a3a1c45) }

var fileDescriptor_6cf7fe261a3a1c45 = []byte{
	// 806 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x4d, 0x6f, 0xd3, 0x4a,
	0x14, 0xad, 0xe3, 0x38, 0x4d, 0x6e, 0xd2, 0xd4, 0x9d, 0x46, 0x91, 0x9f, 0x5f, 0x5e, 0x15, 0x59,
	0x4f, 0x28, 0x42, 0xa8, 0x8b, 0x74, 0x51, 0xb1, 0x23, 0xa4, 0x41, 0x54, 0x2d, 0x72, 0x70, 0xa8,
	0xd4, 0x05, 0x0b, 0x6c, 0x67, 0x4a, 0xad, 0x1a, 0x3b, 0xf5, 0xd8, 0x42, 0x85, 0x15, 0x62, 0xc7,
	0x82, 0x5f, 0x81, 0xf8, 0x9d, 0x68, 0xfc, 0x39, 0xe3, 0xc4, 0x05, 0x75, 0xc3, 0x6e, 0xce, 0x9d,
	0xdc, 0x99, 0x33, 0xf7, 0x9c, 0x7b, 0x1d, 0xe8, 0xda, 0xa6, 0xeb, 0x5a, 0xa6, 0x7d, 0x73, 0xb8,
	0x0a, 0xfc, 0xd0, 0x47, 0xcd, 0x0c, 0x6b, 0x3f, 0x04, 0x90, 0x75, 0x6f, 0xea, 0x7b, 0x1e, 0xb6,
	0x43, 0x03, 0xdf, 0x46, 0x98, 0x84, 0x48, 0x85, 0xe6, 0x05, 0xc1, 0x81, 0x67, 0x7e, 0xc0, 0x8a,
	0x30, 0x14, 0x46, 0x2d, 0x23, 0xc7, 0x74, 0x6f, 0x6e, 0x12, 0xf2, 0xd1, 0x0f, 0x96, 0x4a, 0x6d,
	0x28, 0x8c, 0x3a, 0x46, 0x8e, 0xe9, 0xde, 0xd4, 0x75, 0xb0, 0x17, 0x9e, 0x9e, 0x28, 0x62, 0x92,
	0x97, 0x61, 0xa4, 0x41, 0x67, 0xea, 0x62, 0xd3, 0x5b, 0x60, 0x42, 0x1c, 0xdf, 0x53, 0xea, 0x43,
	0x61, 0xd4, 0x34, 0xb8, 0x18, 0x52, 0x60, 0x7b, 0xb2, 0x5c, 0x06, 0x98, 0x10, 0x45, 0x8a, 0xd3,
	0x33, 0xa8, 0x7d, 0x86, 0x2e, 0xc3, 0x72, 0xe5, 0xde, 0xa1, 0x23, 0x68, 0xa7, 0x78, 0xea, 0x2f,
	0x13, 0x9a, 0xdd, 0xf1, 0xde, 0x61, 0xfe, 0xd0, 0x59, 0x10, 0xd0, 0x0d, 0x83, 0xfd, 0x15, 0xea,
	0x43, 0x63, 0xea, 0xfb, 0x37, 0x0e, 0x4e, 0xa9, 0xa7, 0x08, 0x0d, 0xa0, 0xb5, 0x08, 0xcd, 0xf0,
	0xdc, 0xb4, 0xb0, 0x9b, 0x32, 0x2f, 0x02, 0xda, 0x53, 0xd8, 0x5d, 0x44, 0x16, 0xb1, 0x03, 0xc7,
	0xc2, 0x6f, 0xfc, 0x95, 0x63, 0x13, 0xd4, 0x03, 0x29, 0x5e, 0xa5, 0xe5, 0x49, 0x00, 0x92, 0x41,
	0x7c, 0xed, 0x93, 0xf8, 0x6c, 0xc9, 0xa0, 0x4b, 0xed, 0x8b, 0x00, 0x48, 0xf7, 0xf2, 0xec, 0xac,
	0xc0, 0xc7, 0xd0, 0x5a, 0x44, 0x56, 0x72, 0x96, 0x22, 0x0c, 0xc5, 0x51, 0x7b, 0xfc, 0x4f, 0x41,
	0xbd, 0x74, 0x99, 0x51, 0xfc, 0x96, 0xab, 0x70, 0xad, 0x54, 0xe1, 0xe2, 0x71, 0x22, 0xfb, 0x38,
	0xed, 0x25, 0x55, 0x98, 0xa1, 0x40, 0xab, 0x47, 0x1f, 0x1c, 0xd9, 0x36, 0x26, 0x04, 0x53, 0xbe,
	0xe2, 0xa8, 0x69, 0x14, 0x81, 0xca, 0x93, 0xbe, 0x0a, 0xd0, 0x9b, 0xfb, 0x24, 0xfc, 0xbb, 0xef,
	0x79, 0x02, 0xa8, 0x44, 0x82, 0xbe, 0xa8, 0x42, 0x5a, 0xed, 0x67, 0x6c, 0xf0, 0x79, 0x64, 0xb9,
	0x0e, 0xb9, 0xce, 0xf8, 0x6e, 0x96, 0xef, 0x3e, 0x32, 0xa9, 0xb4, 0x62, 0x2e, 0x2d, 0x35, 0xeb,
	0x2b, 0x4c, 0x88, 0xf9, 0x1e, 0xc7, 0x5e, 0xee, 0x18, 0x19, 0x64, 0xa8, 0x48, 0xd5, 0x2e, 0x6b,
	0x94, 0x5d, 0xe6, 0x52, 0x8b, 0xe7, 0x3c, 0xe9, 0x93, 0x10, 0xd4, 0x17, 0x37, 0xce, 0x2a, 0x26,
	0xd9, 0x34, 0xe2, 0x75, 0xa5, 0x83, 0x7b, 0x20, 0x3d, 0x77, 0x3e, 0xa5, 0x7d, 0xd7, 0x31, 0x12,
	0x50, 0xcd, 0x51, 0xfb, 0x26, 0x40, 0x4f, 0xf7, 0x2e, 0x3c, 0x52, 0x96, 0xb2, 0x0f, 0x0d, 0x46,
	0xc7, 0x96, 0xd1, 0x78, 0xb8, 0x52, 0xe8, 0x11, 0x74, 0xcf, 0x7d, 0x12, 0xa6, 0x1d, 0x58, 0x74,
	0x7d, 0x29, 0x4a, 0x15, 0x2d, 0x71, 0xb9, 0x4f, 0xd1, 0x5b, 0xd8, 0xd7, 0xbd, 0x13, 0x87, 0xd8,
	0x6b, 0x43, 0x2b, 0x27, 0x28, 0x54, 0x12, 0xac, 0xfd, 0x86, 0xa0, 0xb8, 0x91, 0xe0, 0x3e, 0xec,
	0xf1, 0x57, 0xae, 0xdc, 0x3b, 0xed, 0x12, 0x3a, 0xba, 0x37, 0x99, 0x9e, 0x31, 0xa6, 0x4a, 0x24,
	0x10, 0x58, 0x09, 0x1e, 0xe2, 0xf0, 0xff, 0x01, 0xd2, 0x93, 0xef, 0xab, 0xc3, 0xf7, 0xd8, 0xd9,
	0xfa, 0xd5, 0x95, 0xeb, 0x78, 0xf8, 0x4f, 0xaa, 0xc0, 0xb8, 0xa1, 0xc6, 0x3b, 0x36, 0xef, 0x07,
	0x91, 0xed, 0x87, 0xe2, 0xe2, 0x3a, 0x57, 0xb5, 0x3e, 0x34, 0x16, 0x91, 0x85, 0x03, 0x3a, 0xa5,
	0x63, 0x8b, 0x24, 0x48, 0x1b, 0x51, 0x07, 0xe7, 0x7c, 0x78, 0xea, 0x02, 0x7b, 0xc2, 0xe3, 0x2b,
	0xd8, 0x4e, 0xe7, 0x33, 0x6a, 0x81, 0x34, 0x0b, 0x02, 0xfd, 0x4c, 0xde, 0x42, 0xed, 0x38, 0x4a,
	0x6d, 0x2e, 0x0b, 0xa8, 0x03, 0xcd, 0x59, 0x10, 0x4c, 0x2c, 0x3f, 0x08, 0xe5, 0x1a, 0xda, 0x85,
	0x76, 0x9c, 0xe0, 0x85, 0x8e, 0x17, 0x61, 0x59, 0x44, 0x7b, 0xb0, 0x33, 0x0b, 0x82, 0x42, 0x12,
	0xb9, 0x9e, 0x86, 0x26, 0x51, 0x78, 0xfd, 0xc2, 0x74, 0x5c, 0xbc, 0x94, 0xa5, 0xf1, 0x1c, 0x5a,
	0xf9, 0x67, 0x03, 0x4d, 0x59, 0xa0, 0x16, 0xe3, 0xa9, 0xfc, 0xf9, 0x53, 0x95, 0x8d, 0x7b, 0x54,
	0xf2, 0xad, 0xf1, 0x25, 0xb4, 0x99, 0x61, 0x8a, 0x4e, 0x79, 0x38, 0x60, 0x33, 0xcb, 0x53, 0x52,
	0x55, 0x2b, 0x76, 0x93, 0x93, 0xdf, 0xc1, 0x0e, 0x37, 0xd6, 0x90, 0x5e, 0x0e, 0x1c, 0x14, 0xf9,
	0x9b, 0xa6, 0xb0, 0x3a, 0xa8, 0xdc, 0x4f, 0x6e, 0x88, 0xab, 0x91, 0x4e, 0x98, 0xa4, 0x1a, 0x19,
	0xe0, 0x98, 0xf1, 0xb3, 0x92, 0xaf, 0x06, 0x3b, 0x9f, 0x12, 0xce, 0x5c, 0xe3, 0x52, 0xce, 0x7c,
	0xe0, 0x80, 0xcd, 0x5e, 0x1f, 0x37, 0xea, 0xa0, 0x72, 0x3f, 0xb9, 0xe1, 0x2d, 0x6d, 0xb2, 0x42,
	0x66, 0x74, 0x5e, 0xc2, 0xff, 0xb1, 0xf9, 0x6b, 0x43, 0x41, 0xfd, 0xb7, 0x6a, 0x3b, 0x39, 0xfd,
	0x19, 0x48, 0x71, 0xa3, 0xa1, 0xe3, 0x6c, 0xd1, 0x67, 0x13, 0x8a, 0xe6, 0x56, 0x7b, 0x6b, 0x71,
	0xa6, 0xa6, 0xa9, 0xe7, 0x93, 0x9a, 0x66, 0x80, 0xab, 0x29, 0xdf, 0xa5, 0x7c, 0x4d, 0xd9, 0x8e,
	0xd1, 0xb6, 0xac, 0x46, 0xfc, 0x17, 0xed, 0xe8, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x53, 0x57,
	0x61, 0x62, 0xb4, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OnConnectClient is the client API for OnConnect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnConnectClient interface {
	OnConnect(ctx context.Context, in *OnConnectRequest, opts ...grpc.CallOption) (*OnConnectReply, error)
}

type onConnectClient struct {
	cc *grpc.ClientConn
}

func NewOnConnectClient(cc *grpc.ClientConn) OnConnectClient {
	return &onConnectClient{cc}
}

func (c *onConnectClient) OnConnect(ctx context.Context, in *OnConnectRequest, opts ...grpc.CallOption) (*OnConnectReply, error) {
	out := new(OnConnectReply)
	err := c.cc.Invoke(ctx, "/callback.OnConnect/OnConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnConnectServer is the server API for OnConnect service.
type OnConnectServer interface {
	OnConnect(context.Context, *OnConnectRequest) (*OnConnectReply, error)
}

// UnimplementedOnConnectServer can be embedded to have forward compatible implementations.
type UnimplementedOnConnectServer struct {
}

func (*UnimplementedOnConnectServer) OnConnect(ctx context.Context, req *OnConnectRequest) (*OnConnectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnConnect not implemented")
}

func RegisterOnConnectServer(s *grpc.Server, srv OnConnectServer) {
	s.RegisterService(&_OnConnect_serviceDesc, srv)
}

func _OnConnect_OnConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnConnectServer).OnConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnConnect/OnConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnConnectServer).OnConnect(ctx, req.(*OnConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnConnect_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnConnect",
	HandlerType: (*OnConnectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnConnect",
			Handler:    _OnConnect_OnConnect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// OnSubscribeClient is the client API for OnSubscribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnSubscribeClient interface {
	OnSubscribe(ctx context.Context, in *OnSubscribeRequest, opts ...grpc.CallOption) (*OnSubscribeReply, error)
}

type onSubscribeClient struct {
	cc *grpc.ClientConn
}

func NewOnSubscribeClient(cc *grpc.ClientConn) OnSubscribeClient {
	return &onSubscribeClient{cc}
}

func (c *onSubscribeClient) OnSubscribe(ctx context.Context, in *OnSubscribeRequest, opts ...grpc.CallOption) (*OnSubscribeReply, error) {
	out := new(OnSubscribeReply)
	err := c.cc.Invoke(ctx, "/callback.OnSubscribe/OnSubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnSubscribeServer is the server API for OnSubscribe service.
type OnSubscribeServer interface {
	OnSubscribe(context.Context, *OnSubscribeRequest) (*OnSubscribeReply, error)
}

// UnimplementedOnSubscribeServer can be embedded to have forward compatible implementations.
type UnimplementedOnSubscribeServer struct {
}

func (*UnimplementedOnSubscribeServer) OnSubscribe(ctx context.Context, req *OnSubscribeRequest) (*OnSubscribeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnSubscribe not implemented")
}

func RegisterOnSubscribeServer(s *grpc.Server, srv OnSubscribeServer) {
	s.RegisterService(&_OnSubscribe_serviceDesc, srv)
}

func _OnSubscribe_OnSubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnSubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnSubscribeServer).OnSubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnSubscribe/OnSubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnSubscribeServer).OnSubscribe(ctx, req.(*OnSubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnSubscribe_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnSubscribe",
	HandlerType: (*OnSubscribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnSubscribe",
			Handler:    _OnSubscribe_OnSubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// PostSubscribeClient is the client API for PostSubscribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PostSubscribeClient interface {
	PostSubscribe(ctx context.Context, in *PostSubscribeRequest, opts ...grpc.CallOption) (*PostSubscribeReply, error)
}

type postSubscribeClient struct {
	cc *grpc.ClientConn
}

func NewPostSubscribeClient(cc *grpc.ClientConn) PostSubscribeClient {
	return &postSubscribeClient{cc}
}

func (c *postSubscribeClient) PostSubscribe(ctx context.Context, in *PostSubscribeRequest, opts ...grpc.CallOption) (*PostSubscribeReply, error) {
	out := new(PostSubscribeReply)
	err := c.cc.Invoke(ctx, "/callback.PostSubscribe/PostSubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PostSubscribeServer is the server API for PostSubscribe service.
type PostSubscribeServer interface {
	PostSubscribe(context.Context, *PostSubscribeRequest) (*PostSubscribeReply, error)
}

// UnimplementedPostSubscribeServer can be embedded to have forward compatible implementations.
type UnimplementedPostSubscribeServer struct {
}

func (*UnimplementedPostSubscribeServer) PostSubscribe(ctx context.Context, req *PostSubscribeRequest) (*PostSubscribeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostSubscribe not implemented")
}

func RegisterPostSubscribeServer(s *grpc.Server, srv PostSubscribeServer) {
	s.RegisterService(&_PostSubscribe_serviceDesc, srv)
}

func _PostSubscribe_PostSubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostSubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PostSubscribeServer).PostSubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.PostSubscribe/PostSubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PostSubscribeServer).PostSubscribe(ctx, req.(*PostSubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PostSubscribe_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.PostSubscribe",
	HandlerType: (*PostSubscribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostSubscribe",
			Handler:    _PostSubscribe_PostSubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// OnPublishClient is the client API for OnPublish service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnPublishClient interface {
	OnPublish(ctx context.Context, in *OnPublishRequest, opts ...grpc.CallOption) (*OnPublishReply, error)
}

type onPublishClient struct {
	cc *grpc.ClientConn
}

func NewOnPublishClient(cc *grpc.ClientConn) OnPublishClient {
	return &onPublishClient{cc}
}

func (c *onPublishClient) OnPublish(ctx context.Context, in *OnPublishRequest, opts ...grpc.CallOption) (*OnPublishReply, error) {
	out := new(OnPublishReply)
	err := c.cc.Invoke(ctx, "/callback.OnPublish/OnPublish", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnPublishServer is the server API for OnPublish service.
type OnPublishServer interface {
	OnPublish(context.Context, *OnPublishRequest) (*OnPublishReply, error)
}

// UnimplementedOnPublishServer can be embedded to have forward compatible implementations.
type UnimplementedOnPublishServer struct {
}

func (*UnimplementedOnPublishServer) OnPublish(ctx context.Context, req *OnPublishRequest) (*OnPublishReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPublish not implemented")
}

func RegisterOnPublishServer(s *grpc.Server, srv OnPublishServer) {
	s.RegisterService(&_OnPublish_serviceDesc, srv)
}

func _OnPublish_OnPublish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnPublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnPublishServer).OnPublish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnPublish/OnPublish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnPublishServer).OnPublish(ctx, req.(*OnPublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnPublish_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnPublish",
	HandlerType: (*OnPublishServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnPublish",
			Handler:    _OnPublish_OnPublish_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// OnUnsubscribeClient is the client API for OnUnsubscribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnUnsubscribeClient interface {
	OnUnsubscribe(ctx context.Context, in *OnUnsubscribeRequest, opts ...grpc.CallOption) (*OnUnsubscribeReply, error)
}

type onUnsubscribeClient struct {
	cc *grpc.ClientConn
}

func NewOnUnsubscribeClient(cc *grpc.ClientConn) OnUnsubscribeClient {
	return &onUnsubscribeClient{cc}
}

func (c *onUnsubscribeClient) OnUnsubscribe(ctx context.Context, in *OnUnsubscribeRequest, opts ...grpc.CallOption) (*OnUnsubscribeReply, error) {
	out := new(OnUnsubscribeReply)
	err := c.cc.Invoke(ctx, "/callback.OnUnsubscribe/OnUnsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnUnsubscribeServer is the server API for OnUnsubscribe service.
type OnUnsubscribeServer interface {
	OnUnsubscribe(context.Context, *OnUnsubscribeRequest) (*OnUnsubscribeReply, error)
}

// UnimplementedOnUnsubscribeServer can be embedded to have forward compatible implementations.
type UnimplementedOnUnsubscribeServer struct {
}

func (*UnimplementedOnUnsubscribeServer) OnUnsubscribe(ctx context.Context, req *OnUnsubscribeRequest) (*OnUnsubscribeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnUnsubscribe not implemented")
}

func RegisterOnUnsubscribeServer(s *grpc.Server, srv OnUnsubscribeServer) {
	s.RegisterService(&_OnUnsubscribe_serviceDesc, srv)
}

func _OnUnsubscribe_OnUnsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnUnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnUnsubscribeServer).OnUnsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnUnsubscribe/OnUnsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnUnsubscribeServer).OnUnsubscribe(ctx, req.(*OnUnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnUnsubscribe_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnUnsubscribe",
	HandlerType: (*OnUnsubscribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnUnsubscribe",
			Handler:    _OnUnsubscribe_OnUnsubscribe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// OnDisconnectClient is the client API for OnDisconnect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnDisconnectClient interface {
	OnDisconnect(ctx context.Context, in *OnDisconnectRequest, opts ...grpc.CallOption) (*OnDisconnectReply, error)
}

type onDisconnectClient struct {
	cc *grpc.ClientConn
}

func NewOnDisconnectClient(cc *grpc.ClientConn) OnDisconnectClient {
	return &onDisconnectClient{cc}
}

func (c *onDisconnectClient) OnDisconnect(ctx context.Context, in *OnDisconnectRequest, opts ...grpc.CallOption) (*OnDisconnectReply, error) {
	out := new(OnDisconnectReply)
	err := c.cc.Invoke(ctx, "/callback.OnDisconnect/OnDisconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnDisconnectServer is the server API for OnDisconnect service.
type OnDisconnectServer interface {
	OnDisconnect(context.Context, *OnDisconnectRequest) (*OnDisconnectReply, error)
}

// UnimplementedOnDisconnectServer can be embedded to have forward compatible implementations.
type UnimplementedOnDisconnectServer struct {
}

func (*UnimplementedOnDisconnectServer) OnDisconnect(ctx context.Context, req *OnDisconnectRequest) (*OnDisconnectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnDisconnect not implemented")
}

func RegisterOnDisconnectServer(s *grpc.Server, srv OnDisconnectServer) {
	s.RegisterService(&_OnDisconnect_serviceDesc, srv)
}

func _OnDisconnect_OnDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnDisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnDisconnectServer).OnDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnDisconnect/OnDisconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnDisconnectServer).OnDisconnect(ctx, req.(*OnDisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnDisconnect_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnDisconnect",
	HandlerType: (*OnDisconnectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnDisconnect",
			Handler:    _OnDisconnect_OnDisconnect_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// OnACKClient is the client API for OnACK service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnACKClient interface {
	OnACK(ctx context.Context, in *OnACKRequest, opts ...grpc.CallOption) (*OnACKReply, error)
}

type onACKClient struct {
	cc *grpc.ClientConn
}

func NewOnACKClient(cc *grpc.ClientConn) OnACKClient {
	return &onACKClient{cc}
}

func (c *onACKClient) OnACK(ctx context.Context, in *OnACKRequest, opts ...grpc.CallOption) (*OnACKReply, error) {
	out := new(OnACKReply)
	err := c.cc.Invoke(ctx, "/callback.OnACK/OnACK", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnACKServer is the server API for OnACK service.
type OnACKServer interface {
	OnACK(context.Context, *OnACKRequest) (*OnACKReply, error)
}

// UnimplementedOnACKServer can be embedded to have forward compatible implementations.
type UnimplementedOnACKServer struct {
}

func (*UnimplementedOnACKServer) OnACK(ctx context.Context, req *OnACKRequest) (*OnACKReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnACK not implemented")
}

func RegisterOnACKServer(s *grpc.Server, srv OnACKServer) {
	s.RegisterService(&_OnACK_serviceDesc, srv)
}

func _OnACK_OnACK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnACKRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnACKServer).OnACK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnACK/OnACK",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnACKServer).OnACK(ctx, req.(*OnACKRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnACK_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnACK",
	HandlerType: (*OnACKServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnACK",
			Handler:    _OnACK_OnACK_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}

// OnOfflineClient is the client API for OnOffline service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OnOfflineClient interface {
	OnOffline(ctx context.Context, in *OnOfflineRequest, opts ...grpc.CallOption) (*OnOfflineReply, error)
}

type onOfflineClient struct {
	cc *grpc.ClientConn
}

func NewOnOfflineClient(cc *grpc.ClientConn) OnOfflineClient {
	return &onOfflineClient{cc}
}

func (c *onOfflineClient) OnOffline(ctx context.Context, in *OnOfflineRequest, opts ...grpc.CallOption) (*OnOfflineReply, error) {
	out := new(OnOfflineReply)
	err := c.cc.Invoke(ctx, "/callback.OnOffline/OnOffline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OnOfflineServer is the server API for OnOffline service.
type OnOfflineServer interface {
	OnOffline(context.Context, *OnOfflineRequest) (*OnOfflineReply, error)
}

// UnimplementedOnOfflineServer can be embedded to have forward compatible implementations.
type UnimplementedOnOfflineServer struct {
}

func (*UnimplementedOnOfflineServer) OnOffline(ctx context.Context, req *OnOfflineRequest) (*OnOfflineReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnOffline not implemented")
}

func RegisterOnOfflineServer(s *grpc.Server, srv OnOfflineServer) {
	s.RegisterService(&_OnOffline_serviceDesc, srv)
}

func _OnOffline_OnOffline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnOfflineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OnOfflineServer).OnOffline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/callback.OnOffline/OnOffline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OnOfflineServer).OnOffline(ctx, req.(*OnOfflineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OnOffline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "callback.OnOffline",
	HandlerType: (*OnOfflineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnOffline",
			Handler:    _OnOffline_OnOffline_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "callback.proto",
}
